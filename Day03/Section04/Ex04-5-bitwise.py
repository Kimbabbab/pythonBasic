'''
비트 연산자
    어떤 변수의 값을 0과 1의 조합인 2진수,
    즉 비트로 변환한 뒤에 비트단위로 연산 수행

    1. &(AND) : 입력이 모두 1이면 1, 아니면 0(곱셈) # 1*0 = 0
    2. |(OR) : 입력 중 하나라도 1이면 1, 아니면 0(덧셈) # 1+1 != 0
    3. ^(XOR) : 입력이 서로 다르면 1, 아니면 0 # exclusive or(배타적 논리합)
    4. ~(NOT) : 입력이 0이면 1, 입력이 1이면 0
    5. <<(왼쪽 SHIFT) : 비트 단위로 왼쪽으로 N비트 이동하며 2의 N 거듭제곱만큼 곱셈
    6. >>(오른쪽 SHIFT) : 비트 단위로 오른쪽으로 N비트 이동하며 2의 N 거듭제곱만큼 나눗셈

'''

# 1byte = 8bit
# int 형은 4byte: 32bit 사용 가능, 1bit는 부호를 나타내고 31bit로 숫자를 구현(범위: -2**31 ~ 2**31-1)
# 3 = (0)0..0011

a = 6 # = (0)0..0110 <- 제일 앞의 비트는 부호, 0은 양수, 1은 음수
b = 5 # = (0)0..0101
print('a & b : {}'.format(a & b)) # = (0)0..0100
print('a | b : {}'.format(a | b)) # = (0)0..0111
print('a ^ b : {}'.format(a ^ b)) # = (0)0..0011
print('~a : {}'.format(~a)) # = (1)1..1001 // -(16-9) = -7
print('~b : {}'.format(~b)) # = (1)1..1010 // -(16-10) = -6
# 컴퓨터는 덧셈만 하지 뺄셈은 하지 못한다, 덧셈을 용이하게 하려고 2의 보수(complement)라는 개념을 만들었다

'''
0 -> 0000
-0 -> 1111(1의 보수) + 1 -> 10000 -> 0000(캐리 1을 버려줌)
'''
print('a << 1 : {}'.format(a << 1)) # 1100
print('a >> 1 : {}'.format(a >> 1)) # 0011